<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title></title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="WhatAndHow.html">What is IWindow And How Can I Build It</a></li><li class="chapter-item expanded affix "><a href="WindowClass.html">Window Class</a></li><li class="chapter-item expanded affix "><a href="GamepadInput.html">Gamepad Input</a></li><li class="chapter-item expanded affix "><a href="Callbacks.html">Callbacks</a></li><li class="chapter-item expanded affix "><a href="Vulkan.html">Vulkan</a></li><li class="chapter-item expanded affix "><a href="OpenGL.html">OpenGL</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="what-is-iwindow"><a class="header" href="#what-is-iwindow">What is IWindow</a></h1>
<p>IWindow is a windowing library that is meant to be used with Vulkan or OpenGL. </p>
<p>The goal of IWindow is:</p>
<ul>
<li>IWindow should be cross-platform and work with Win32 (Windows) and X11 (Linux) windowing apis but currently there is only a Win32 version.</li>
</ul>
<h1 id="how-can-i-build-iwindow"><a class="header" href="#how-can-i-build-iwindow">How can I build IWindow?</a></h1>
<p>IWindow uses the <a href="https://premake.github.io/">premake5</a> build system.</p>
<p>IWindow comes with premade premake projects to build easily to a static library. These projects are <code>IWindowWin32GL</code> and <code>IWindowWin32Vk</code>. As the name suggests GL is for OpenGL projects and Vk is for Vulkan. There is also a <code>IWindowWin32All</code> project for OpenGL and Vulkan. </p>
<h1 id="important-stuff-you-should-know-about"><a class="header" href="#important-stuff-you-should-know-about">Important Stuff You Should Know About</a></h1>
<p><strong>All</strong> functions/classes are in the <code>IWindow</code> namespace.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-class"><a class="header" href="#window-class">Window Class</a></h1>
<p>The window class is where the magic happens. The window class as the name suggests is the class that is reponsible for creating the window on your screen.</p>
<p>The window class is kept in the IWindow.h header file.</p>
<p>This is what the window class .h file looks like (with some stuff taken out).</p>
<pre><code class="language-cpp">namespace IWindow {
    class Window {
    public:
        Window() = default;
        Window(int64_t width, int64_t height, const std::string&amp; title, int64_t x = 100, int64_t y = 100);
        ~Window(); 

        bool Create(int64_t width, int64_t height, const std::string&amp; title, int64_t x = 100, int64_t y = 100);

        void Update();

        bool IsRunning();

        NativeWindowHandle&amp; GetNativeWindowHandle(); 

        Vector2 GetWindowSize();
        Vector2 GetWindowPosition();

        Vector2 GetMousePosition();

        void SetWindowSize(int64_t width, int64_t height);
        void SetWindowPosiiton(int64_t x, int64_t y);

        bool IsKeyDown(Key key);
        template&lt;typename... Args&gt;
        bool IsKeyDown(Key key, Args... args) { return IsKeyDown(key) &amp;&amp; IsKeyDown(args...); }

        bool IsKeyUp(Key key);
        template&lt;typename... Args&gt;
        bool IsKeyUp(Key key, Args... args) { return IsKeyUp(key) &amp;&amp; IsKeyUp(args...); }

        bool IsMouseButtonDown(MouseButton button);
        template&lt;typename... Args&gt;
        bool IsMouseButtonDown(MouseButton button, Args... args) { return IsMouseButtonDown(button) &amp;&amp; IsMouseButtonDown(args...); }

        bool IsMouseButtonDoubleClicked(MouseButton button);
        template&lt;typename... Args&gt;
        bool IsMouseButtonDoubleClicked(MouseButton button, Args... args) { return IsMouseButtonDoubleClicked(button) &amp;&amp; IsMouseButtonDoubleClicked(args...); }

        bool IsMouseButtonUp(MouseButton button);
        template&lt;typename... Args&gt;
        bool IsMouseButtonUp(MouseButton button, Args... args) { return IsMouseButtonUp(button) &amp;&amp; IsMouseButtonUp(args...); }

        void SetUserPointer(void* ptr);
        void* GetUserPointer();

        void SetPosCallback(WindowPosCallback callback);
        void SetSizeCallback(WindowSizeCallback callback);
        void SetKeyCallback(KeyCallback callback);
        void SetMouseMoveCallback(MouseMoveCallback callback);
        void SetMouseButtonCallback(MouseButtonCallback callback);

        NativeGLDeviceContext&amp; GetNativeGLDeviceContext();
        
        void operator=(Window&amp;) = delete;
        Window(Window&amp;) = delete;
    };
}
</code></pre>
<p>Its a lot to take in right even though this is only the public stuff. Dont worry we will be going through everything in the window class.</p>
<h2 id="main-functions"><a class="header" href="#main-functions">Main Functions</a></h2>
<p><code>bool IWindow::Window::Create(int64_t width, int64_t height, const std::string&amp; title, int64_t x = 100, int64_t y = 100)</code> creates the window you could use the constructor (which takes in the same args) but <code>Create</code> returns a <code>false</code> if something fails. </p>
<p>Example:</p>
<pre><code class="language-cpp">    IWindow::Window window{};
    if (!window.Create(...)) return -1;
    
    // Or

    // Doesn't return bool if fails
    window = IWindow::Window(...);
</code></pre>
<p><code>bool IWindow::Window::IsRunning()</code> checks if the window is still up and running. <code>IsRunning</code> with return <code>false</code> if a window is not running (e.g. when a user clicks the x in the top of the window isRunning will return <code>false</code>).</p>
<p>Example:</p>
<pre><code class="language-cpp">while (window.IsRunning()) {
    // do stuff
}
</code></pre>
<p><code>void IWindow::Window::Update()</code> checks for events like input or if the window moved and should be called every frame.</p>
<p>Example:</p>
<pre><code class="language-cpp">    while(window.isRunning()) {
        // do stuff
        
        window.Update();
    }
</code></pre>
<h2 id="getters-and-setters"><a class="header" href="#getters-and-setters">Getters And Setters</a></h2>
<p><code>Vector2 IWindow::Window::GetWindowSize()</code> returns a <code>IWindow::Vector2</code> which is</p>
<pre><code class="language-cpp">    struct Vector2 {
        int64_t y, x;
    };
</code></pre>
<p>where <code>x</code> and <code>y</code> are width and height of the window.</p>
<p><code>void IWindow::Window::SetWindowSize(int64_t width, int64_t height)</code> takes in 2 <code>int64_t</code> (64 bit integer) width, height. This function sets the width and height of the window.</p>
<p><code>void IWindow::Window::SetWindowPosition(int64_t x, int64_t x)</code> takes in 2 <code>int64_t</code> (64 bit integer) x, y. This function sets the window position.</p>
<p><code>Vector2 IWindow::Window::GetWindowPosition()</code> return a <code>IWindow::Vector2</code>. Where <code>x</code> and <code>y</code> are the window position.</p>
<p>The <code>void IWindow::Window::SetPosCallback</code>, <code>void IWindow::Window::SetKeyCallback</code>, etc. are called when an action like moving the window or a key is pressed happens. For more info goto the <a href="./Callbacks.html">Callbacks section</a>.</p>
<p>Example:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt; // For std::cout

void WindowPosCallback(IWindow::Window&amp; window, int64_t x, int64_t y) {
    int* example = (int*)window.GetUserPointer();
    std::cout &lt;&lt; &quot;User Pointer: &quot; &lt;&lt; example &lt;&lt; '\n'; // Output: 10
    std::cout &lt;&lt; &quot;Window position: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; '\n';
}

An example of a `WindowPosCallback` is
```cpp
#include &lt;iostream&gt; // For std::cout

void WindowPosCallback(IWindow::Window&amp; window, int64_t x, int64_t y) {
    std::cout &lt;&lt; &quot;Window position: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; '\n';
}
</code></pre>
<p><code>x</code> and <code>y</code> are the <code>x</code> and <code>y</code> coordinates of the window.</p>
<p><code>void IWindow::Window::SetUserPointer(void* ptr)</code> sets an internal pointer that can be retreived in a callback or some where else.</p>
<pre><code>int main() {
    ...

    int example = 10;
    // window = IWindow::Window
    window.SetUserPointer(&amp;example);
    window.SetPosCallback(WindowPosCallback);
    ...
}

</code></pre>
<p><code>void* IWindow::Window::GetUserPointer()</code> gets the pointer set from <code>IWindow::Window::SetUserPointer</code>. <code>nullptr</code> if no pointer is set</p>
<h2 id="input-functions"><a class="header" href="#input-functions">Input Functions</a></h2>
<p>The <code>bool IWindow::Window::IsKeyDown(IWindow::Window::Key key)</code> and <code>IWindow::Window::IsKeyUp(IWindow::Window::Key key)</code> functions check if a key is pressed or is released. A key callback could be used to handle this.</p>
<p><code>bool IWindow::Window::IsMouseButtonDown(IWindow::MouseButton button)</code> and <code>bool IWindow::Window::IsMouseButtonUp(IWindow::MouseButton button)</code> functions check if a argument <code>button</code> is pressed or released. </p>
<p><code>bool IWindow::Window::IsMouseButtonDoubleClicked(IWindow::MouseButton button)</code> checks if a argument <code>button</code> was pressed 2 in quick succesion.</p>
<p>The templated input functions allow you to pass in multiple buttons/keys and the function checks if all the buttons/keys are pressed/released.</p>
<p>Example:</p>
<pre><code class="language-cpp">...
// statment will be true if the left and right buttons are pressed
// window = IWindow::Window
if (window.isMouseButtonDown(IWindow::MouseButton::Left, IWindow::MouseButton::Right)) {
    ...
}

...
</code></pre>
<h2 id="advanced-functions"><a class="header" href="#advanced-functions">Advanced Functions</a></h2>
<p><code>NativeWindowHandle&amp; IWindow::Window::GetNativeWindowHandle()</code> gets the internal windowing api's window handle (e.g. Win32: <code>HWND</code>, X11: <code>Window</code>).</p>
<p><code>NativeGLDeviceContext&amp; IWindow::Window::GetNativeGLDeviceContext()</code> gets the internal windowing api's graphics/device context (e.g. Win32: <code>HDC</code>, X11: <code>GC</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gamepad-input-in-iwindow"><a class="header" href="#gamepad-input-in-iwindow">Gamepad Input In IWindow</a></h1>
<p>Gamepad input is pretty simple in IWindow. </p>
<p>There is a seperate class for gamepad input instead of being in the window class.</p>
<p>IWindow can only have upto 4 gamepads connected to the whole application.</p>
<p>The class is <code>IWindow::Gamepad</code>.</p>
<pre><code class="language-cpp">namespace IWindow {
    class Gamepad {
    public:
        Gamepad() = default;
        Gamepad(GamepadID gamepadIndex);

        bool IsLeftStickInDeadzone();
        bool IsRightStickInDeadzone();

        float LeftStickX();
        float LeftStickY();
        float RightStickX();
        float RightStickY();

        float LeftTrigger(); 
        float RightTrigger();

        bool IsButtonDown(GamepadButton button);
        template &lt;typename ... Args&gt;
        bool IsButtonDown(GamepadButton button, Args... args) { return IsButtonDown(button) &amp;&amp; IsButtonDown(args...); }

        bool IsButtonUp(GamepadButton button);
        template &lt;typename ... Args&gt;
        bool IsButtonUp(GamepadButton button, Args... args) { return IsButtonUp(button) &amp;&amp; IsButtonUp(args...); }

        GamepadState GetState();
        GamepadID GetID();
        bool IsConnected();

        static void SetConnectedCallback(GamepadConnectedCallback callback);

        static void SetUserPointer(GamepadID gid, void* ptr);
        static void* GetUserPointer(GamepadID gid);

        // 0.0f = cancel, 1.0f max speed
        void Rumble(float leftMotor = 0.0f, float rightMotor = 0.0f);

        void Update();
    };
}

</code></pre>
<h2 id="main-functions-1"><a class="header" href="#main-functions-1">Main Functions</a></h2>
<p><code>IWindow::Gamepad::Gamepad(IWindow::GamepadID gamepadIndex)</code> takes in 1 argument, <code>IWindow::GamepadID gamepadIndex</code>. Game index is one of the 4 available controller slots.</p>
<p><code>void IWindow::Gamepad::Update()</code> updates the gamepad state. call this every frame.</p>
<p><code>bool IWindow::Gamepad::IsLeftStickInDeadzone()</code> and <code>bool IsRightStickInDeadzone()</code> checks if the controller is in the dead zone of the left/right stick.</p>
<p><code>float IWindow::Gamepad::LeftStickX()</code> and <code>float IWindow::Gamepad::RightStickX()</code> gets the value of how far is the sticks x axis is to the left (-1) or right (0) on the left/right stick.</p>
<p><code>float IWindow::Gamepad::LeftStickY()</code> and <code>float IWindow::Gamepad::RightStickY()</code> gets the value of how far is the sticks y axis is to the bottom (-1) or top (1) on the left/right stick.</p>
<p><code>float IWindow::Gamepad::LeftTrigger()</code> and <code>float IWindow::Gamepad::RightTrigger()</code> gets the value of how much the left/right trigger is down. The functions return 0 if the left/right trigger completly up or it will return 1 if the left/right trigger completly down.</p>
<p><code>bool IWindow::Gamepad::IsButtonDown(GamepadButton button)</code> checks if argument <code>button</code> is being pressed. An example of a <code>GamepadButton</code> is <code>GamepadButton::A</code>  and <code>GamepadButton::B</code>.</p>
<p><code>bool IWindow::Gamepad::IsButtonUp(GamepadButton button)</code> checks if argument <code>button</code> is not being pressed.</p>
<p><code>IWindow::GamepadID IWindow::Gamepad::GetID()</code> gets the id return the ID that was passed to the constructor. </p>
<p><code>bool IWindow::Gamepad::IsConnected()</code> checks if the a controller with the ID of the value passed into the constructor is connected.</p>
<p><code>static void IWindow::Gamepad::SetConnectedCallback(GamepadConnectedCallback callback)</code> sets the connected callback. Check out <a href="./Callbacks.html">Callbacks</a> for more info.</p>
<p><code>static void IWindow::Gamepad::SetUserPointer(IWindow::GamepadID gid, void* ptr)</code> sets a pointer that is associated to the GamepadID.
<code>static void* IWindow::Gamepad::GetUserPointer(IWindow::GamepadID gid)</code> gets the pointer associated with the GamepadID. nullptr if no pointer is set.</p>
<p><code>void IWindow::Gamepad::Rumble(float leftMotor = 0.0f, float rightMotor = 0.0f)</code> vibrates the gamepads motors. leftMotor controlles the left motor on the gamepad and the rightMotor controlles the right motor on the gamepad. Setting the a value to 0 will stop vibrations and setting it to 1 will set the motors to the max speed.</p>
<h2 id="advanced-functions-1"><a class="header" href="#advanced-functions-1">Advanced Functions</a></h2>
<p><code>GamepadState IWindow::Gamepad::GetState()</code> get the native gamepad api's state (e.g. XInput: <code>XINPUT_STATE</code>).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="callbacks-in-iwindow"><a class="header" href="#callbacks-in-iwindow">Callbacks In IWindow</a></h1>
<p>A callback is a function that is called during a certain event.</p>
<h2 id="window-callbacks"><a class="header" href="#window-callbacks">Window Callbacks</a></h2>
<h4 id="window-position-callback"><a class="header" href="#window-position-callback">Window Position Callback</a></h4>
<p>The window position callback is called when the window is being moved;</p>
<ul>
<li>The <code>IWindow::Window&amp;</code> argument is the window that called the callback. </li>
<li>The first <code>int64_t</code> argument is the new x position of the window.</li>
<li>The second <code>int64_t</code> argument is the new y position of the window.</li>
</ul>
<p>The internal x and y position will be automatically updated. So there is no need to call <code>window.SetPosition</code> on the window.</p>
<p>To register a window position callback, call <code>window.SetPosCallback(callback)</code>. Where window is a IWindow::Window.</p>
<p>An example of a window position callback is:</p>
<pre><code class="language-cpp">void WindowPosCallback(IWindow::Window&amp; window, int64_t x, int64_t y) {
    std::cout &lt;&lt; &quot;Window position: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; '\n';
}

...

// IWindow::Window
window.SetPosCallback(WindowPosCallback);
</code></pre>
<h4 id="window-size-callback"><a class="header" href="#window-size-callback">Window Size Callback</a></h4>
<p>The window size callback is called when the window is being resized;</p>
<ul>
<li>The <code>IWindow::Window&amp;</code> argument is the window that called the callback. </li>
<li>The first <code>int64_t</code> argument is the new width position of the window.</li>
<li>The second <code>int64_t</code> argument is the new height position of the window.</li>
</ul>
<p>The internal width and height position will be automatically updated. So there is no need to call <code>window.SetSize</code> on the window.</p>
<p>To register a window size callback, call <code>window.SetSizeCallback(callback)</code>. Where window is a IWindow::Window.</p>
<p>An example of a window size callback is:</p>
<pre><code class="language-cpp">void WindowSizeCallback(IWindow::Window&amp; window, int64_t width, int64_t height) {
    std::cout &lt;&lt; &quot;Window size: &quot; &lt;&lt; width &lt;&lt; &quot;, &quot; &lt;&lt; height &lt;&lt; '\n';
}

...

// window is a IWindow::Window
window.SetSizeCallback(WindowPosCallback);
</code></pre>
<h2 id="input-callbacks"><a class="header" href="#input-callbacks">Input Callbacks</a></h2>
<h4 id="key-callback"><a class="header" href="#key-callback">Key Callback</a></h4>
<p>The key callback is called when a key is pressed on the key board.</p>
<ul>
<li>The <code>IWindow::Window&amp;</code> argument is the window that called the callback. </li>
<li>The <code>IWindow::Key</code> argument is the key that was pressed (e.g. <code>Key::A</code>, <code>Key::B</code>, etc.)</li>
<li>The <code>IWindow::InputState</code> argument says if the key was pressed or released.</li>
</ul>
<p>to register a key callback, call <code>window.SetKeyCallback()</code>. Where window is a IWindow::Window.</p>
<p>An example of a key callback is:</p>
<pre><code class="language-cpp">void KeyCallback(IWindow::Window&amp; window, IWindow::Key key, IWindow::InputState state) {
    std::cout &lt;&lt; &quot;Key &quot; &lt;&lt; key &lt;&lt; &quot; was just &quot; &lt;&lt; state &lt;&lt; '\n';
}

...

window.SetKeyCallback(KeyCallback);
</code></pre>
<h4 id="mouse-button-callback"><a class="header" href="#mouse-button-callback">Mouse Button Callback</a></h4>
<p>The mouse button is called when a mouse button is pressed.</p>
<ul>
<li>The <code>IWindow::Window&amp;</code> is the window that called the callback.</li>
<li>The <code>IWindow::MouseButton</code> is what button was pressed.</li>
<li>The <code>IWindow::InputState</code> is what input state (e.g. Down, Up) the button is in.</li>
<li>The <code>IWindow::ClickState</code> is what click state the button is in (e.g. single clicked, double clicked).</li>
</ul>
<p>to register a mouse button callback, call <code>window.SetMouseButtonCallback()</code>. Where window is a <code>IWindow::Window</code>.</p>
<p>An example of a mouse button callback is:</p>
<pre><code class="language-cpp">void MouseButtonCallback(IWindow::Window&amp; window, IWindow::MouseButton button, IWindow::InputState iState, IWindow::ClickState cState) {

}

...

window.SetMouseButtonCallback(MouseButtonCallback);

</code></pre>
<h4 id="mouse-move-callback"><a class="header" href="#mouse-move-callback">Mouse Move Callback</a></h4>
<p>The mouse move callback is called when the cursor moves.</p>
<ul>
<li>The <code>IWindow::Window&amp;</code> argument is the window that called the callback.</li>
<li>The first <code>int64_t</code> argument is the cursors x position.</li>
<li>The second <code>int64_t</code> argument is the cursors y position.</li>
</ul>
<p>to register a mouse move callback for callback, call <code>window.SetMouseMoveCallback()</code>. Where window is a <code>IWindow::Window</code>.</p>
<p>An example of a mouse move callback is:</p>
<pre><code class="language-cpp">void MouseMoveCallback(IWindow::Window&amp; window, int64_t x, int64_t y) {
    std::cout &lt;&lt; &quot;Mouse Moved: &quot; &lt;&lt; x &lt;&lt; &quot;, &quot; &lt;&lt; y &lt;&lt; '\n';
}

...

// window = IWindow::Window
window.SetMouseMoveCallback(MouseMoveCallback);

</code></pre>
<h4 id="gamepad-connected-callback"><a class="header" href="#gamepad-connected-callback">Gamepad Connected Callback</a></h4>
<p>The gamepad connected callback is called when a gamepad is connected. </p>
<ul>
<li>The <code>IWindow::GamepadID</code> argument is the ID of the gamepad that was connected/disconnected.</li>
<li>The <code>bool</code> argument is if the gamepad was connected/disconnected. Connected if true and disconnected if false.</li>
</ul>
<p>to register a gamepad connected callback, call <code>IWindow::Gamepad::SetConnectedCallback()</code>. The callback will be set for every gamepad thats why its static.</p>
<p>An example of a gamepad connected callback is:</p>
<pre><code class="language-cpp">void GamepadConnectedCallback(IWindow::GamepadID gid, bool isConnected) {
    const char* sConnected = &quot;&quot;;

    switch (isConnected)
    {
    case true:
        sConnected = &quot;connected&quot;;
        break;
    case false:
        sConnected = &quot;disconnected&quot;;
    default:
        break;
    }


    std::cout &lt;&lt; &quot;Gamepad &quot; &lt;&lt; (int)gid &lt;&lt; &quot; was &quot; &lt;&lt; sConnected &lt;&lt; &quot;!\n&quot;;
}

...

IWindow::Gamepad::SetConnectedCallback(GamepadConnectedCallback);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-with-iwindow"><a class="header" href="#vulkan-with-iwindow">Vulkan with IWindow</a></h1>
<p>IWindow needs some isntance extensions to create a <code>VkSurfaceKHR</code>. On Win32 the extensions are <code>VK_KHR_WIN32_SURFACE_EXTENSION_NAME</code> and <code>VK_KHR_SURFACE_EXTENSION_NAME</code>. On X11 the extensions are <code>VK_KHR_XLIB_SURFACE_EXTENSION_NAME</code> and <code>VK_KHR_SURFACE_EXTENSION_NAME</code>.</p>
<p>All of the classes/functions in the page is on <code>IWindowVK.h</code>.</p>
<p>To get the required extensions IWindow has a function.</p>
<p><code>void IWindow::Vk::GetRequiredInstanceExtensions(std::vector&lt;const char*&gt;&amp; extentionNames)</code></p>
<p>Example:</p>
<pre><code class="language-cpp">    ...

    std::vector&lt;const char*&gt; iWindowExtensionNames;
    IWindow::Vk::GetRequiredInstanceExtensions(iWindowExtensionNames);

    VkInstanceCreateInfo instanceInfo{};
    instanceInfo.sType = VK_STRUCTURE_TYPE_INSTANCE_CREATE_INFO;
    instanceInfo.pApplicationInfo = &amp;appInfo;
    instanceInfo.enabledExtensionCount = (uint32_t)iWindowExtensionNames.size();
    instanceInfo.ppEnabledExtensionNames = iWindowExtensionNames.data();

    ...
</code></pre>
<p>IWindow will create a <code>VkSurfaceKHR</code> for you since its platform dependent.</p>
<p><code>VkResult IWindow::Vk::CreateSurface(VkInstance instance, VkSurfaceKHR&amp; surface, Window&amp; window)</code>.</p>
<p>This is pretty self explanitory. The function takes in an instance, a surface that will be modified and a <code>IWindow::Window&amp;</code>. The function will return the output of the vk create function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="opengl-with-iwindow"><a class="header" href="#opengl-with-iwindow">OpenGL with IWindow</a></h1>
<p>IWindow will handle creating the OpenGL context with the <code>IWindow::GL::Context</code> class and <code>IWindow::GL::LoadOpenGLFunction(const char* name)</code>.</p>
<p>everything in this page is in the <code>IWindowGL.h</code> header file.</p>
<pre><code class="language-cpp">// in IWindowGL.h
namespace IWindow {
    namespace GL {
        class Context {
        public:
            Context() = default;
            Context(Window&amp; window, uint16_t majorVersion, uint16_t minorVersion);
            ~Context();
            
            bool Create(Window&amp; window, uint16_t majorVersion, uint16_t minorVersion);

            void MakeContextNotCurrent();
            void MakeContextCurrent();

            void SwapBuffers();

            void operator=(Context&amp;) = delete;
            Context(Context&amp;) = delete;
        };

        void* LoadOpenGLFunction(const char* name);
    }
}
</code></pre>
<p>The context class is less complecated than than the window class.</p>
<h2 id="main-functions-2"><a class="header" href="#main-functions-2">Main Functions</a></h2>
<p>like the window class the Context class has two ways you can create it with and the same rules that applied to the window class applies here. These two ways are the constructor and the <code>Create</code> function. <code>Create</code> already makes the OpenGL context current.</p>
<p>After you create the context you can then initialize any opengl function loaders like glad and glew. </p>
<p>Example:</p>
<pre><code class="language-cpp">    ...
    IWindow::GL::Context glContext;

    if (!glContext.Create(...)) HandleError();

    ...

    while(window.IsRunning()) {
        ...
        window.Update();
    }

    ...
</code></pre>
<p><code>void IWindow::GL::Context::MakeContextCurrent()</code> makes the OpenGL renderering context to be current.</p>
<p><code>void IWindow::GL::Context::SwapBuffers()</code> Swaps the front and back framebuffers should be called every frame.</p>
<p>Example:</p>
<pre><code class="language-cpp">    ...
    while(window.IsRunning()) {
        window.Update();
        glContext.SwapBuffers();
    }
    ...
</code></pre>
<h2 id="advanced-functions-2"><a class="header" href="#advanced-functions-2">Advanced Functions</a></h2>
<p><code>void* IWindow::GL::LoadOpenGLFunction(const char* name)</code> loads a function from OpenGL the dlls.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
